MASTER PLAN
_____________________________________


Alright, strap in. You want to build a top-class, offline, visually stunning finance tracker primarily for India, using AI with zero coding knowledge. This is an ambitious project, especially the "100% accuracy" and complex parsing requirements, but it's absolutely achievable with the right plan, tools, and iterative approach.

As the world's leading expert in turning complex ideas into reality, I can tell you that success here hinges on structure, choosing the right battle-tested technologies, and understanding *how* to leverage AI effectively for development, not just asking it to "build the app."

Let's break it down.

**The Core Challenge: 100% Data Extraction Accuracy & PDF Parsing**

You hit the nail on the head. PDF parsing, especially extracting structured transaction data from varied, often unstructured or semi-structured bank statements, is *hard*. Achieving 100% accuracy out-of-the-box for *all* possible bank statement formats from India (and internationally) is frankly, near impossible with a single, static rule set. Bank statement formats change, they use different layouts, date formats, currency symbols, and table structures.

Your workaround idea is excellent: **Convert PDF to a structured format (like CSV or a parsable internal representation) on the device, then parse that structured data.** This is the most robust offline approach. However, the *conversion* step itself still relies on accurately extracting text and identifying tabular data within the PDF. Even the best libraries might miss data or misinterpret table structures on some PDFs.

**Therefore, a "zero tolerance policy" for data extraction *must* include a mechanism for user review and correction of imported data *after* the automated extraction.** The goal of the automation should be *very high accuracy* (e.g., 95-99%+ depending on statement variety), minimizing the need for manual correction, but the app *must* allow the user to fix any errors to truly achieve 100% *accurate data in the system*.

**Proposed Full Stack**

Considering your requirements (offline, stunning UI, performance, cross-platform Android/Web, AI-friendly, industry-leading) and zero coding background leveraging AI, here is the optimal stack:

1.  **Frontend & Cross-Platform Framework:** **Flutter**
    *   **Why:**
        *   **Stunning UI & Performance:** Built for beautiful, fast UIs with smooth animations (Skia graphics engine). Perfect for your visualization requirements and "butter smooth" feel.
        *   **Single Codebase:** Develop for Android and Web (Desktop) from a single Dart codebase. Saves immense time and effort compared to separate native development.
        *   **Growing Ecosystem & Community:** Strong industry adoption.
        *   **AI-Friendly (Relative):** Dart is a clean, modern language with good tooling, which can make AI code generation more predictable and easier to integrate than languages with more complex syntax or dynamic behavior (like JavaScript in React Native, though RN is also viable). Flutter's widget-based structure is also quite logical.
2.  **Programming Language:** **Dart**
    *   **Why:** The language Flutter uses. Statically typed, relatively easy to learn, and performs well.
3.  **Offline Database:** **Isar Database**
    *   **Why:**
        *   **Optimized for Flutter:** Built from the ground up for Dart/Flutter.
        *   **Extremely Fast:** One of the fastest embedded databases available for Flutter. Crucial for fast filtering, querying, and managing large amounts of transaction data offline.
        *   **Easy to Use:** Developer-friendly API.
        *   **Supports Complex Data:** Handles structured and nested data well.
4.  **State Management:** **Riverpod**
    *   **Why:**
        *   **Robust and Scalable:** Excellent for managing application state in complex apps like this.
        *   **Type-Safe:** Reduces bugs.
        *   **Provider-Based:** Logical and easier to reason about than some alternatives, which helps when integrating code generated by AI.
5.  **Data Parsing (The Hard Part):**
    *   **PDF Extraction:**
        *   **Library:** `syncfusion_flutter_pdf` or `pdf` (for text extraction) + **Custom Logic**. You'll likely need to extract text blocks and then apply sophisticated pattern matching, potentially heuristic rules, or even a small on-device ML model (more complex) to identify transaction tables/lines. This is where the majority of parsing development effort will go.
    *   **Excel/CSV Parsing:**
        *   **Libraries:** `excel` (for .xlsx), `csv` (for .csv). These are relatively straightforward once you have the file data.
    *   **SMS Parsing:**
        *   **Libraries:** `permission_handler` (for permissions), `sms_maintained` (to read SMS).
        *   **Custom Logic:** Advanced pattern matching (Regex) and potentially keyword analysis to identify transaction messages and extract sender, amount, date, reference (UPI). Need robust logic to handle variations and duplicates.
    *   **UPI Detail Extraction & Categorization (Indian Focus):**
        *   **Custom Logic:** This will build on the SMS/Statement parsing. UPI transactions often have a specific structure in the description (e.g., `UPI/Debit/PhonePe/merchant-name/ref-id`). You'll need to develop a rule-based or ML system to parse these descriptions, identify merchants, and categorize transactions.
        *   **Merchant/Bank Logos:** Store a local database (perhaps JSON or within Isar) mapping common bank/merchant names (extracted from parsing) to local image assets.
6.  **Visualizations:** **Syncfusion Flutter Charts** (or similar high-end charting library like `fl_chart` if it adds 3D)
    *   **Why:** Syncfusion often provides a wide range of chart types (check specifically for 3D donut/pie), high performance, interactivity, and customization needed for stunning visuals. You may need to combine libraries or potentially implement custom drawing for a specific 3D exploding effect if not directly supported, but start with a powerful library.
7.  **Authentication:** **`local_auth`** (for biometrics) + **`flutter_secure_storage`** (for securely storing PIN/Pattern hashes or flags) + **Custom UI** for PIN/Pattern entry.
8.  **Currency Handling:** **`intl`** library (for formatting) + **Custom Logic** for storing base currency, exchange rates (can be manually updated by user or periodic fetch if a tiny bit of online allowed, but for *pure* offline, user inputs rates), and converting values on the fly for display.
9.  **UI/UX:** Leverage Flutter's rich widget catalog, custom painting, and animation framework. Design system principles (color themes, typography, spacing).

**Why this stack?**

*   It directly addresses the core requirements: Performance, UI quality, offline capability, cross-platform.
*   Flutter/Dart combined with Isar provides a powerful, fast, and maintainable foundation for an offline-first, data-heavy app.
*   The parsing layer is identified as the most complex custom part, requiring dedicated logic regardless of stack, but Flutter allows building this efficiently.
*   It's popular and well-documented, which helps when using AI tools â€“ AI models are trained on vast amounts of public code, making them generally better at generating code in popular stacks.

**Architecture Design (Offline-First)**

A clean, layered architecture is essential for maintainability and managing complexity:

1.  **Presentation Layer (UI):**
    *   Flutter Widgets, Pages, Components.
    *   Responsible for rendering the UI, handling user input, and displaying data.
    *   Interacts *only* with the Application/State Management Layer.
2.  **Application/State Management Layer:**
    *   Riverpod providers and logic.
    *   Acts as the bridge between UI and Business Logic/Data.
    *   Holds the current state of the UI (e.g., selected filters, current budget view, data being displayed).
    *   Triggers actions in the Business Logic layer based on user interaction.
    *   Feeds data received from Business Logic to the UI.
3.  **Business Logic Layer:**
    *   Pure Dart classes.
    *   Contains the core logic of the application:
        *   Filtering and aggregating transaction data.
        *   Budget calculation.
        *   Handling multi-user profiles.
        *   Currency conversion logic.
        *   Implementing comparison logic (YoY, MoM, etc.).
        *   Validation rules.
    *   Interacts with the Data Layer to fetch/save data.
4.  **Data Layer:**
    *   Manages all data persistence and retrieval.
    *   **Database Repository:** Handles interaction with the Isar database (saving transactions, fetching transactions by filters, etc.). This abstracts the database details from the business logic.
    *   **Parsing Modules:** Contains the logic for:
        *   Reading raw file data (PDF, Excel, CSV).
        *   Extracting text/tables from PDFs.
        *   Parsing structured data (Excel, CSV) into a common transaction format.
        *   Parsing SMS messages.
        *   Applying UPI/merchant identification rules.
        *   Implementing duplicate detection logic.
    *   **File/SMS Access:** Handles interacting with the device's file system (`file_picker`, `path_provider`) and SMS inbox (`sms_maintained`).

**Data Flow (Upload Scenario):**

1.  User selects a file (PDF, Excel, CSV) via File Picker (Presentation Layer).
2.  UI triggers an "Import Statement" action (Application Layer).
3.  Application Layer calls the Data Layer's Parsing Module.
4.  Parsing Module:
    *   Reads the file content.
    *   *If PDF:* Uses PDF extraction library + custom logic to get potential transaction data.
    *   *If Excel/CSV:* Uses respective library to parse data into a standard format.
    *   Applies UPI/Merchant identification logic.
    *   **Crucially:** Creates a list of *potential* transactions in a standardized format.
    *   **Duplicate Detection:** Compares these potential transactions against existing transactions in the Database Repository using heuristics (date, amount, description similarity, reference IDs, etc.). Marks potential duplicates.
5.  Parsing Module returns the list of *potential* transactions (with duplicate flags and parsing success indicators) to the Application Layer.
6.  Application Layer updates state to show a "Review Import" screen in the UI (Presentation Layer).
7.  User reviews the parsed data (Presentation Layer), corrects errors, resolves potential duplicates.
8.  User confirms import (Presentation Layer).
9.  UI triggers "Confirm Import" action (Application Layer).
10. Application Layer passes the final, user-approved list of transactions to the Business Logic Layer.
11. Business Logic Layer applies final validation and categorization rules.
12. Business Logic Layer passes validated transactions to the Data Layer's Database Repository.
13. Database Repository saves the transactions into Isar Database.
14. Database Repository notifies listeners (Application Layer) that data has changed.
15. Application Layer updates the UI (Presentation Layer) to show the new data in charts/lists.

**Splitting into Small Packages/Modules (Code Structure)**

Organize your codebase logically. In Flutter, this often means folders for:

*   `lib/` (main source code)
    *   `data/`: Database repository, Isar models, Parsing modules (pdf, excel, csv, sms, upi), File/SMS access wrappers.
    *   `domain/`: Pure business logic (filters, aggregations, budget calculator, currency converter, duplicate checker logic). This layer should *not* depend on Flutter or Isar directly.
    *   `presentation/`: UI code (screens, widgets, themes, custom chart rendering).
        *   `screens/`: Top-level pages (Dashboard, Import, Budgets, Settings).
        *   `widgets/`: Reusable UI components (Transaction list item, Filter bar, Chart widgets).
        *   `charts/`: Custom visualization components.
        *   `themes/`: Color palettes, typography, theme logic.
    *   `application/`: Riverpod providers, state management logic, orchestrating calls between UI and Domain/Data.
    *   `utils/`: Helper functions (date formatting, currency formatting).
    *   `assets/`: Images (logos), fonts, configuration files.

**Workflow**

This project requires an iterative approach, especially with AI assistance.

1.  **Planning & Design (You):** Detail features, create mockups (even rough sketches), define data requirements (what fields go into a Transaction object?), map out user flows (how does import work step-by-step?). Use the documents provided here.
2.  **Task Breakdown (You/AI Assist):** Break down features into tiny, manageable coding tasks (e.g., "Create Transaction data model," "Implement Save button for manual entry," "Read text from PDF file using library X," "Write regex to find amount in SMS").
3.  **AI Code Generation (You + AI):** Use AI for specific tasks.
    *   Prompt: "Write me a Dart class for an Isar database transaction model with fields: amount (double), date (DateTime), description (String), category (String), transactionType (enum: credit/debit), accountId (String), source (enum: manual/upload/sms), originalText (String, for parsing), isDuplicate (bool), needsReview (bool)."
    *   Prompt: "Show me how to use the `file_picker` library in Flutter to let the user select a PDF file."
    *   Prompt: "Give me Dart code using the `excel` library to read the first sheet of an Excel file and print the values in column A and B."
    *   Prompt: "How do I set up Riverpod for basic state management in Flutter?"
    *   Prompt: "Write a Flutter widget to display a transaction list item with description and amount."
    *   **Be specific!** Don't ask "Build the import feature."
4.  **Integration & Manual Coding (You):** This is where your role is crucial. AI generates snippets; *you* need to integrate them, connect different parts, handle edge cases AI missed, and write the complex *logic* that's unique to your app (like the specific parsing rules for UPI or duplicate detection heuristics). You will spend more time integrating and debugging than just copying and pasting.
5.  **Testing (You):** **Test *everything* rigorously, especially the parsing logic.** Prepare sample bank statements (PDF, Excel, CSV) and SMS messages covering various formats and edge cases.
6.  **Refactoring (You):** As code grows, reorganize, simplify, and improve its structure and performance. AI can sometimes help refactor snippets, but understanding *why* you're refactoring is key.
7.  **Repeat:** Move to the next small task. Build features incrementally.

**Master Plan (Phased Step-by-Step Approach)**

This is a high-level plan. Each step breaks down into many smaller coding tasks.

*   **Phase 0: Setup & Foundation ( ~1-2 weeks )**
    1.  Install Flutter, Dart, IDE (VS Code or Android Studio).
    2.  Create a new Flutter project.
    3.  Add necessary dependencies (`isar`, `riverpod`, `file_picker`, `intl`, basic UI libraries like `cupertino_icons`).
    4.  Define core data models (Transaction, Account, Category, Budget, User/Family Member).
    5.  Set up Isar database integration (define schemas, create basic repository methods like `saveTransaction`, `getTransactions`).
    6.  Implement basic app structure (main app widget, routing).
    7.  Set up basic theming (color palettes, dark mode structure).
    8.  Implement device Biometric/PIN/Pattern authentication flow.

*   **Phase 1: Manual Entry & Basic Display ( ~2-3 weeks )**
    9.  Build UI for manual transaction entry (form with fields, date picker, category selector).
    10. Implement logic to save manual entries to Isar via the repository.
    11. Build a simple transaction list display screen (showing manual entries).
    12. Implement basic filtering by date range and account.
    13. Implement manual transaction deletion.

*   **Phase 2: Core File Import (Excel & CSV) & Review ( ~3-4 weeks )**
    14. Build UI for file selection (using `file_picker`).
    15. Implement reading Excel (.xlsx) files using the `excel` library.
    16. Implement reading CSV (.csv) files using the `csv` library.
    17. Develop initial core parsing logic: Given structured data (from Excel/CSV rows), attempt to map columns to Transaction model fields (date, amount, description). This will require configuration or intelligent mapping.
    18. Implement a "Review Imported Data" screen: Display parsed transactions before saving, allowing user edits and corrections.
    19. Implement logic to save reviewed/corrected transactions to Isar.

*   **Phase 3: Advanced Import & Duplicate Detection ( ~4-6 weeks )**
    20. Integrate a PDF text/table extraction library (`syncfusion_flutter_pdf` or `pdf`).
    21. Develop sophisticated custom logic for parsing raw text/tables extracted from PDFs into the standard transaction format. This is highly iterative and requires testing with many statement types.
    22. Implement SMS reading using `sms_maintained`.
    23. Develop pattern matching (Regex) and logic for extracting transaction details from common SMS formats.
    24. Develop robust duplicate detection logic comparing new parsed transactions (from any source) against existing Isar data. Mark potential duplicates.
    25. Enhance the "Review Imported Data" screen to show duplicate flags and provide tools to resolve duplicates (merge, ignore, replace).
    26. Implement logic to save final, deduplicated transactions.

*   **Phase 4: Visualizations & Reporting ( ~5-7 weeks )**
    27. Integrate a charting library (`syncfusion_flutter_charts`).
    28. Implement queries in the Data Layer (Isar) to aggregate data needed for charts (e.g., sum of expenses per category for a month).
    29. Build interactive chart widgets:
        *   Smooth Bar Chart (Expenses/Income per month/day).
        *   Line Trends (Cumulative spending, spending trends over time).
        *   Donut Chart (Category breakdown). Implement basic interactivity (tooltips on hover/tap).
    30. **Challenge: 3D Exploding Donut:** Research library capabilities. If not direct, explore custom painting or combining libraries. This might be complex with AI alone. *Allocate significant time/research.*
    31. Implement filtering UI for charts/reports (date ranges, accounts, categories).
    32. Implement Comparison Logic (YoY, MoM, YTD, PYTD, QTD, PQTD) and hook it up to charts/reports. This requires fetching and comparing different date ranges of data.
    33. Implement the ability to switch between different chart types for the same data set.

*   **Phase 5: Advanced Features & Polish ( ~4-6 weeks )**
    34. Implement Multi-user support: Modify data models to link transactions/accounts/budgets to user profiles. Build UI for switching profiles. (Note: Assuming single-device multi-user for offline constraint).
    35. Implement Account management: UI to add/edit/delete bank accounts, link transactions to accounts.
    36. Implement Currency Preference: UI to select base currency. Add logic to store exchange rates (manual input). Implement currency conversion in the Business Logic Layer. Update all relevant UI elements, charts, tooltips to display values in the selected currency.
    37. Implement Category management: UI to add/edit categories, assign icons/colors.
    38. Build Budgeting features:
        *   UI to set budgets per category per time period (monthly, yearly).
        *   Logic to track spending against budgets.
        *   Budget reporting screen with visual indicators (progress bars).
        *   Implement filters and time comparisons for budget reports.
    39. Enhance UI: Implement rich colors, animations, micro-interactions. Ensure modern, elegant look and feel.
    40. Implement Bank/Merchant logos: Store logos locally, enhance parsing logic to map parsed names to logo assets, display logos in transaction lists/details.
    41. Ensure responsiveness: Make sure layout adapts well to different screen sizes (phone, tablet, desktop window).

*   **Phase 6: Refinement, Performance & Testing ( ~3-4 weeks )**
    42. **Extensive Testing:** Perform unit, widget, integration, and end-to-end tests. **Crucially, test the import/parsing logic with *many* real-world statement samples.**
    43. **Performance Optimization:** Profile the app. Identify and fix performance bottlenecks, especially in data querying, parsing, and rendering complex charts with large datasets. Ensure memory management is efficient (Isar helps here, but watch out for holding large lists in memory unnecessarily).
    44. Refactor code for clarity and maintainability based on lessons learned during development.
    45. Gather feedback (UAT - User Acceptance Testing) from potential users, especially regarding the import accuracy and usability.
    46. Prepare for release (build process, app signing).

**Total Estimated Time:** ~22-31 weeks (5-7 months). This is a significant project, even with AI. The parsing and visualization complexity are the biggest variables.

**Testing Strategy**

Testing is paramount, especially for a finance app where accuracy is critical.

1.  **Unit Tests:** Test individual functions or methods in isolation (e.g., the function that calculates YoY comparison, the function that attempts to parse a single line of text, a specific regex for SMS). Write these alongside development.
2.  **Widget Tests:** Test individual Flutter widgets (e.g., does the transaction list item display the correct data? Does the filter widget update correctly?).
3.  **Integration Tests:** Test the interaction between different parts of the app (e.g., does saving a manual transaction via the UI correctly write to the database? Does selecting a date filter update the chart data?).
4.  **End-to-End Tests:** Simulate full user flows (e.g., User uploads a PDF -> reviews data -> confirms import -> checks if transactions appear correctly in the list and charts).
5.  **Data Parsing Specific Tests (CRITICAL):**
    *   Create a large suite of test files (PDFs, Excels, CSVs) covering various banks, formats, edge cases (different date formats, missing fields, unusual characters, split transactions if applicable).
    *   Create corresponding "expected output" data for each test file.
    *   Automate tests that run your parsing logic against these files and compare the output to the expected data. This suite will grow over time as you encounter new statement formats.
    *   Similarly, create a test suite of various transaction SMS messages and their expected parsed data.
6.  **User Acceptance Testing (UAT):** Get real users (especially Indian users with diverse bank statements) to use pre-release versions. Their feedback on parsing accuracy and usability is invaluable.

**Refactoring Plan**

Refactoring isn't a separate phase you do *once*. It's an ongoing process.

*   **Plan for it:** Allocate time in your schedule (e.g., 10-15% of development time).
*   **When to Refactor:**
    *   Before adding a new major feature to a complex area.
    *   When you find code that is hard to understand or modify.
    *   When you identify performance bottlenecks.
    *   When similar code is duplicated in multiple places.
    *   After receiving feedback (e.g., UI feels clunky, data loading is slow).
*   **How to Refactor (with AI):**
    *   Identify a specific piece of code to improve (e.g., a long function, a complex UI widget).
    *   Use AI: "Refactor this Dart function to be more readable and efficient:" [paste code]. Or "Can you suggest a better way to structure these Flutter widgets?"
    *   **Verify:** AI suggestions aren't always perfect. Understand *what* the AI changed and *why*. Test the refactored code thoroughly to ensure you didn't break anything.
    *   Refactor in small steps.

**Mind Map Concept**

A mind map is a visual tool to organize information. For this project, it could help you:

*   **Break down Features:** Start with the central idea "Offline Finance App". Branch out to main features (Data Import, Visualizations, Budgeting, Accounts, Users, Settings). Branch out further for sub-features (Data Import -> File Select, PDF Parse, Excel Parse, SMS Parse, Duplicate Check, Review Screen).
*   **Identify Dependencies:** Draw connections between features (e.g., Visualizations depends on Data Import and Filtering; Budgeting depends on Categories and Transactions).
*   **Plan Development:** Use it to visualize the scope and prioritize which branches to build first (e.g., Foundation -> Manual Entry -> Core Import -> Visualizations...).
*   **Data Model Relationships:** Map out how your data models (Transaction, Account, Category, User) relate to each other.

You don't need complex software; pen and paper or a simple online tool works. It's about visually structuring the complexity.

**Things to Be Aware Of for Success (Using AI)**

1.  **AI is an Assistant, Not an Autonomous Developer:** It won't understand your entire vision from one prompt. You are the architect, the project manager, and the final code integrator/debugger.
2.  **Structured Prompts are Key:** Be highly specific in your AI prompts. Provide context, desired output format, and constraints.
3.  **Verify and Understand Generated Code:** *Never* copy and paste AI code without reading and understanding it. Does it fit your architecture? Is it efficient? Could it have side effects? Does it handle errors?
4.  **Debugging is Inevitable:** Code generated by AI will have bugs. You *must* be prepared to debug, which requires learning the basics of using a debugger in your IDE.
5.  **Integrating AI Snippets is Harder Than Generating Them:** The real work is stitching together different AI-generated parts, making them work with your existing codebase, and ensuring data flows correctly between them.
6.  **Complex Logic is Still Mostly You:** AI is good at boilerplate, standard algorithms, and common patterns. Highly specific business logic, like your exact UPI parsing rules or nuanced duplicate detection, will require significant manual effort and refinement, guided but not fully written by AI.
7.  **Maintaining 100% Accuracy is the Hardest Technical Challenge:** Be prepared for this to be an ongoing effort. It will require continuous testing with new statement formats and potentially releasing updates just to improve parsing for specific banks. The user correction step is your safety net.
8.  **Don't Get Stuck on Perfection Early:** Get core functionality working (manual entry, basic list). Then add CSV/Excel import. *Then* tackle the harder PDF/SMS. Build iteratively.
9.  **Community is Your Friend:** Even using AI, you will run into issues. Flutter has a great community. Learn how to search for solutions on Stack Overflow, GitHub issues, or Flutter forums. AI can help summarize solutions, but you still need to find them.
10. **Version Control (Git):** Learn the basics of Git. Commit your code frequently. This is your safety net if something goes wrong or if AI generates code that breaks everything; you can easily revert.

**Alternative for PDF Parsing (Your Workaround Elaborated)**

Your suggestion is sound. Instead of trying to directly parse *from* PDF text, the workflow is:

1.  **User Uploads PDF.**
2.  **App Uses a Library to Extract *Raw Text and Table Structures* from PDF.** Libraries like `syncfusion_flutter_pdf` or `pdf` can do this to varying degrees of success depending on the PDF complexity. Some might give you text blocks, others might identify tables.
3.  **App Applies Parsing Logic to the Extracted Text/Tables.** This is where your custom code kicks in. It analyzes the structure, looks for keywords ("Debit", "Credit", dates, currency symbols), identifies rows that look like transactions, and attempts to map columns/fields based on proximity, headers, or learned patterns.
4.  **Standardize and Validate:** Convert the identified potential transactions into your app's internal Transaction model format.
5.  **Review & Correct:** Present to the user for validation.

This is the most practical offline approach. It's not converting to a *separate* Excel file that the user sees, but converting the PDF *structure* internally into a format your parsing logic can work with (like a list of potential table rows or text blocks).

**Conclusion**

Building a top-tier app with complex features like robust offline parsing, stunning visuals, and multi-user support is a significant undertaking. Your vision is clear, and the proposed stack with Flutter and Isar is well-suited for it, especially given the UI and offline performance requirements.

Leveraging AI is a smart move for someone without coding experience, but view AI as your highly capable, but sometimes unpredictable, assistant. You are the lead developer. You need to provide the structure, break down the tasks, integrate the pieces, and critically test the results.

The key challenges will be the 100% data extraction accuracy (which requires user review), the complexity of PDF and SMS parsing across diverse formats, and ensuring smooth performance with potentially large local datasets and complex visualizations.

Follow the phased plan, focus on building core features first, test relentlessly (especially the parsing!), and be prepared for iterative refinement. You have a solid roadmap now. Use this document to guide your AI prompts and structure your development process.

Go build that app! You've got this.